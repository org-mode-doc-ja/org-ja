#!/usr/bin/perl
# Auto warpping script for a texinfo file generated by po4a-translate
#                                          Last Update: 2011-11-14@03:41
#                                          Takaaki ISHIKAWA  <takaxp@ieee.org>
#
#  (*) If you are perl professional, please advice to me or improve this :-)

use strict;
use warnings;
use File::Copy;
use Encode;
use utf8;
use encoding 'utf8';
use open ":utf8";
use open ":std";

print "Make a new texi file with valid wrap for generateing an INFO file\n";

my $backup = 'org-ja_bak.texi';
my $texinfo = 'org-ja.texi';
my $wrap = '76';
my $stringcode = 'utf-8';

my $debug_wrap_limit = '16';

my $global_line_status = "";

# Backup the target file.
(-f $texinfo) or die ("$texinfo: $!\n");
(-f $backup) or die ("$backup: $!, please touch $backup\n");
copy($texinfo, $backup) or die ("ERROR: FILE COPY $!");

# Read the original texinfo file generated by po4a-translate
open(IN,"< $texinfo") or die("ERROR: OPEN A FILE $!");
my @src = <IN>;
close(IN);

# Replace (，．) with (、。)
my $dst = &replace_marks(\@src);
$dst = &pre_processing($dst);
$dst = &get_valid_texinfo_data($dst);

# Replace \p{UTF-8}\n\p{UTF-8} to \p{UTF-8}\p{UTF-8}
#$dst = &subs_unexpected_break($dst);

open(OUT,"> $texinfo") or die("ERROR: FAIL TO OPEN A FILE $!");
foreach my $line (@$dst){
    chomp($line);
    print OUT $line."\n";
}
close(OUT);

1;

###############################################################################
sub replace_marks {
    my $src = shift;
    my @dst = ();

    foreach my $line (@$src){
	$line =~ s/．/。/g;
	$line =~ s/，/、/g;
	push(@dst, $line);
    }
    return \@dst;
}

sub bytecount {
    my $line = shift;
    my $length = length(encode($stringcode,$$line)); # length = abc[U][U]=3+6=9
    my $ascii=0;
    for(my $i=0; $i<length($$line); ++$i){           # length = abc[U][U]=5
	if(&is_ascii(encode($stringcode,substr($$line,$i,1)))){ ++$ascii; }
    }
    my $utf = $length-$ascii;
    my $width = 2*$utf/3+$ascii;
#    print $length."\t".$width."\t".$ascii."\t".$utf."\t(".$$line.")\n";
    return $width;
}

# Check the line is finished with "@hoge{".
sub is_open_bracket {
    my $line = shift;
    $$line =~ /@[^\}@]+?{[^\}]*$/;
}

# Check the line is finished in @ref{, @xref{, or @pxref{
sub is_open_ref_bracket {
    my $line = shift;
    $$line =~ /@[r|xr|pxr]ef{[^\}]*$/;
}

# Check the line is begun with "hoge}".
sub is_close_bracket {
    my $line = shift;
    $$line =~ /^[^\{]*?}/;
}

sub is_utf {
    $_[0] !~ /[\x20-\x7f]/; # ascii codes
}

sub is_ascii {
    $_[0] =~ /[\x20-\x7f]/; # ascii codes
}

sub get_split_position {
    my $words = shift;
    # The line has 0 or 1 word.
    if(@$words < 2){
	return @$words;
    }

    my $count = 0;
    my $buffer = "";
    my $anchor = 0;
    # The line has at least 2 words.
    for(my $i=0; $i<@$words; ++$i){
	if(&is_ascii($$words[$i])){
	    ++$count;
	}else{
	    $count += 2;
	}

	$buffer .= $$words[$i];
	if(&is_utf($$words[$i-1]) && &is_ascii($$words[$i])){
	    $anchor = $i;
	}
	# update virtual_wrap
	my $virtual_wrap = &get_virtual_wrap(\$buffer);
	if($count > $virtual_wrap){
#	    print "break: $anchor\t".$$words[$i-1]."\t".$$words[$i]."\n";
	    if( &is_ascii($$words[$i-1]) && &is_ascii($$words[$i]) ||
		&is_open_ref_bracket(\$buffer)){
		return $anchor;
	    }
	    return $i;
	}
    }

    return @$words;
}

sub get_virtual_wrap {
    my $buffer = shift;

    my @commands = ();
    while($$buffer =~ /(@[^\}@]+?)[{ ]/g){
	push(@commands,$1);
    }

    my $virtual_wrap = $wrap;
    foreach my $command (@commands){
#	print "command: $command\n";
	if($command eq "\@LaTeX"){      # "@LaTeX{}" => "LaTeX", 8 => 5
	    $virtual_wrap += 3;
	}elsif($command eq "\@bullet"){ # "@bullet{}" => "*", 9 => 1
	    $virtual_wrap += 8;
	}elsif($command eq "\@r"){      # "@r{}" => "", 4 => 0
	    $virtual_wrap += 4;         
	}elsif($command eq "\@i"){      # "@i{}" => "", 4 => 0
	    $virtual_wrap += 4;         
	}elsif($command eq "\@b"){      # "@b{}" => "", 4 => 0
	    $virtual_wrap += 4;         
	}elsif($command eq "\@item"){   # "@item " => "", 6 => 0
	    $virtual_wrap += 6;         
	}else{
	    $virtual_wrap += length($command);
	}
    }

    if( $$buffer =~ /^(.*?)@\*.*?$/){
	$virtual_wrap += &bytecount(\$1);
    }

    if($global_line_status ne ""){
	$virtual_wrap -= 6;
    }

    return $virtual_wrap;
}

sub update_line_status {
    my $buffer = shift;
    if($$buffer =~ /^\@table|^\@itemize|^\@enumerate/){
	$global_line_status = "true";
    }elsif($$buffer =~ /^\@end table|^\@end itemize|^\@end enumerate/){
	$global_line_status = "";
    }
}

sub get_valid_texinfo_data {
    my $src = shift;
    my @dst = ();
    print "=================== START ==========================\n";
    my $count = 0;
    my $buffer = "";
    foreach my $line (@$src){
	chomp($line);
	print STDERR ++$count."/".@$src."\r";
	if(&brackets_validation(\$buffer)){
	    &update_line_status(\$buffer);
	    &flash_buffer(\@dst,\$buffer);
	    $buffer = $line;
	}else{
	    $buffer .= " ".$line;
	}
    }
    if($buffer ne ""){
	&flash_buffer(\@dst,\$buffer);
    }
    print "==================== END  =========================\n";
    return \@dst;
}

sub flash_buffer {
    my ($dst, $buffer) = @_;
    my @lines = split /\n/, $$buffer;
    if(@lines == 0){
	push(@lines,$$buffer);
    }

    my $wraped_string = "";
    my $count = 0;
    foreach my $line (@lines){
	$count = &bytecount(\$line);
	print ">>>> INPUT::\n".$line."\n";
	if($count > $wrap && $line !~ /^\@node/){
	    # many translated sentences will pass through
	    $wraped_string = &get_wraped_string(\$line);
	    print "<<<< OUTPUT::\n";
	    my @wraped_lines = split /\n/, $$wraped_string;
	    foreach my $wraped_line (@wraped_lines){
		my $wraped_count = &bytecount(\$wraped_line);
		if($wraped_count>$wrap+$debug_wrap_limit &&
		   $wraped_count!=length($wraped_line)){
		    print "<< something wrong! >>\n";
		}
		if($global_line_status eq ""){
		    print $wraped_count."::".$wraped_line."\n";
		}else{
		    print $wraped_count.":|".$wraped_line."\n";
		}
	    }
	    print "\n----------------\n\n";	    
	    push(@$dst,$$wraped_string);
	}else{
	    # many original sentences will pass through
	    print "<<<< OUTPUT::\n".$line."\n----------------\n\n";
	    push(@$dst,$line);
	}
    }
    $$buffer = "";    
}

sub get_wraped_string {
    my $line = shift;
    my @words = split //, $$line;
    my $stream = ""; # line with LF codes
    my $buffer = $$line;
    my $word_count = &bytecount($line);
    my @code_stack = ();

    print "文字数 = ".@words.", バイト数 = ".$word_count."\n";
    if(@words == $word_count){
	# Line is composed of ascii codes without any utf codes.
	# makeinfo will be able to handle this line properly.
	return $line;
    }

    my $prev_count = $word_count;
    while($word_count > $wrap){
	&insert_linebreak(\$stream,\$buffer);
	$word_count = &bytecount(\$buffer);
	# avoid infinity loop
	if($word_count >= $prev_count && $word_count > 0){
	    $word_count = 0;
	}
	$prev_count = $word_count;
    }	

    if($buffer ne ""){
	$stream .= $buffer."\n";
    }
    return \$stream;
}

sub insert_linebreak {
    my ($stream, $buffer) = @_;
    my ($buffer1, $buffer2) = &split_buffer($buffer);
    $$stream .= $$buffer1."\n";
    $$buffer = $$buffer2;
}

# Get the first index of the 2nd buffer
sub split_buffer {
    my $buffer = shift;
    my @words = split //, $$buffer;
    my $split_position = &get_split_position(\@words);
    my $buffer1 = "";
    my $buffer2 = "";
    if($split_position == 0){
	print "No stack.\n";
	return ($buffer, \$buffer2);
    }
    for(my $i=0; $i<$split_position; ++$i){
	$buffer1 .= $words[$i];
    }
    for(my $i=$split_position; $i<@words; ++$i){
	$buffer2 .= $words[$i];
    }
    return(\$buffer1, \$buffer2);
}

sub brackets_validation {
    my $line = shift;
    my $local_line = $$line;
    &remove_bracket_escapes(\$local_line);
    my @words = split //, $local_line;
    my $begin_count = 0;
    my $end_count = 0;
    foreach my $word (@words){
	if( $word eq "{" ){ ++$begin_count; }
	if( $word eq "}" ){ ++$end_count; }
    }
    if($begin_count == $end_count){
	return 1;
    }
    print "Brackets mismatch!\n";
    print "{ = ".$begin_count.", } = ".$end_count.".\n";
    print $local_line."\n";
    return 0;
}

sub remove_bracket_escapes {
    my $line = shift;
    $$line =~ s/@@//g;
    $$line =~ s/@\{//g;
    $$line =~ s/@\}//g;
}

sub pre_processing {
    my $src = shift;
    my @dst = ();
    my $buffer = "";
    foreach my $line (@$src){
	chomp($line);

	# @table @var will be cause of MOJIBAKE with UTF-8
	$line =~ s/\@table \@var/\@table \@code/;

	# @orgcmd{\\,org-agenda-filter-by-tag-refine}, only for org7.5
	$line =~ s/\@orgcmd\{\\,/\@orgcmd\{\\\\,/;

	# if($line =~ /^\@item $/){
	#     push(@dst,"\@item \@w\{ \}");
	#     next;
	# }

	# Remove unexpected line break (@item\nhoge => @item hoge)
	if($line =~ /^\@item +$/){
	    if($buffer ne ""){
		exit;
	    }
	    $buffer = "\@item ";
	}else{
	    push(@dst,$buffer.$line);
	    $buffer = "";
	}
    }
    return \@dst;
}


# inactive functions #########################################################

sub update_brackets_count {
    my ($line, $count) = @_;
    if(&is_close_bracket($line)){
	--$$count;
    }
    if(&is_open_bracket($line)){
	++$$count;
    }
}
