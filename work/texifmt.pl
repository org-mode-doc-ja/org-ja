#!/usr/bin/perl
# Auto warp script for a texinfo file generated by po4a-translate
#                               2011-04-22  Takaaki ISHIKAWA  <takaxp@ieee.org>
#
#  (*) If you are perl professional, please advice to me or improve this :-)
#
use strict;
use warnings;
use File::Copy;
use Encode;
use utf8;
use encoding 'utf8';
use open ":utf8";
use open ":std";

print "Make a new texi file with valid wrap for generateing an INFO file\n";

my $backup = 'org-ja_bak.texi';
my $texinfo = 'org-ja.texi';
my $wrap = '74';
my $stringcode = 'utf-8';

# Backup the target file.
(-f $texinfo) or die ("$texinfo: $!\n");
(-f $backup) or die ("$backup: $!, please touch $backup\n");
copy($texinfo, $backup) or die ("ERROR: FILE COPY $!");

# Read the original texinfo file generated by po4a-translate
open(IN,"< $texinfo") or die("ERROR: OPEN A FILE $!");
my @src = <IN>;
close(IN);

# Replace \p{UTF-8}\n\p{UTF-8} to \p{UTF-8}\p{UTF-8}
&subs_unexpected_break(\@src);
my $dst = &get_valid_texinfo_data(\@src);
open(OUT,"> $texinfo") or die("ERROR: FAIL TO OPEN A FILE $!");
foreach my $line (@{$dst}){
    chomp($line);
    print OUT $line."\n";
}
close(OUT);

1;

###############################################################################
sub bytecount {
    my $length = length(encode($stringcode,$_[0])); # abc[U][U]=3+6=9
    my $ascii=0;
    my $i=0;
    for($i=0;$i<length($_[0]);++$i){                # abc[U][U]=5
	if(substr($_[0],$i,1) =~ /[\x20-\x7f]/){ ++$ascii; }
    }
    my $utf = $length-$ascii;
#    print $length."\t".$ascii."\t".$utf."\t(".$_[0].")\n";
    return 2*$utf/3+$ascii;
}
sub is_divided {
    $_[0] =~ /\@.+{[^}]+$/;
}
sub is_breakable {
    $_[0] !~ /[\x20-\x7f]/; # ascii codes
}
sub is_exception {
    $_[0] =~ /^\@c|^\@set|^\@item|^\@node/;
}
sub is_conflict_free {
    ($_[0] eq 'i' || $_[0] eq 'b') ? return 1 : return 0;
#    ($_[0] eq 'i' || $_[0] eq 'b'|| $_[0] eq 'footnote') ? return 1 : return 0;
}
sub get_valid_texinfo_data {
    my $buffer = "";
    my @dst = ();
    print "=============================================\n";
    foreach my $line (@{$_[0]}){
	chomp($line);
	if(!&is_divided($line)){
	    $line = $buffer.$line;
	    my $count = &bytecount($line);
	    if($count >= $wrap && !&is_exception($line)){
		# many translated sentences will pass through
		# print "$count: $line"."\n\n";
		print "INPUT:\n".$line." :INPUT\n";
		my $wraped_string = &get_wraped_string($line);
		print "OUTPUT:\n".$$wraped_string." :OUTPUT\n";
		push(@dst,$$wraped_string);
	    }else{
		# many original sentences will pass through
		push(@dst,$line);
	    }
	    $buffer = "";
	}else{
	    $buffer .= $line." ";
	}
    }
    print "=============================================\n";
    return \@dst;
}
sub subs_unexpected_break {
    my @dst = ();
    foreach my $line (@{$_[0]}){
# nothing to do, now
    }
    return \@{$_[0]};
}

# This function will insert LF code into appropriate positions on line.
# e.g.
# 1: ...............................$wrap
# 2: ..............................LF...|     no control code
# 3: .............................LF....|     no control code
# 4: ..........................LF@hoge{...}   (@ref{})
# 5: ....@hoge{...................LF....|     (@i{}, @b{})
# 6: ....@hoge{................LF@hoge{...}   (@i{...@ref{})
#
sub get_wraped_string {
    my @words = split //, $_[0];
    my $stream = "";
    my $word_count = 0;
    my @code_stack = ();

    foreach my $word (@words){
	$word_count += &bytecount($word);
	if($word =~ /^\@$/){ # Never insert LF code
	    push(@code_stack, $word);
	}else{
	    if($#code_stack < 0){ # No texinfo code nesting
		$stream .= $word;
#		if($word_count >= $wrap){
		if($word_count >= $wrap && &is_breakable($word)){
		    $stream .= "\n";
		    print $word_count."\n";
		    $word_count = 0;
		}
	    }else{                # texinfo code nesting
		$code_stack[$#code_stack] .= $word;
		# Insert a Line Feed code ( \n@hoge{ or @hoge{...\n)
#		if($word_count >= $wrap){
		if($word_count >= $wrap && &is_breakable($word)){
		    if($code_stack[$#code_stack] =~ /^\@(.+){/){
			if(&is_conflict_free($1)){
			    $code_stack[$#code_stack] .= "\n";
			}else{
			    $code_stack[$#code_stack]
				= "\n".$code_stack[$#code_stack];
			}
			print $word_count."\n";
			$word_count = 0;
		    }
		}
		# Check completion of texinfo code (e.g. @hoge{ })
		if($word =~ /^\}$/){
		    if($#code_stack > 0){ # multiple nesting
			$code_stack[$#code_stack-1]
			    .= $code_stack[$#code_stack];
#			print $code_stack[$#code_stack]."\n";
		    }elsif($#code_stack == 0){ # single nesting
			$stream .= $code_stack[$#code_stack];
		    }
		    pop(@code_stack);
		}
	    }
	}
    }

    # for a case of missing '}' (e.g. @hoge{ ... @hoge{ ... } )
    if($#code_stack >= 0){
	foreach my $line (@code_stack){
	    $stream .= $line;
	}
    }
    return \$stream;
}
